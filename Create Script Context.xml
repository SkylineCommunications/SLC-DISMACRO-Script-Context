<?xml version="1.0" encoding="utf-8" ?>
<DisMacro xmlns="http://www.skyline.be/dis">
	<Description>Add a ScriptContext class that parses you script parameters.</Description>
	<Author>SKYLINE2\AMA</Author>
	<Script>
		<Code>
			<![CDATA[using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Windows;
using System.Xml.Linq;
using Create_Script_Context_1;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using Microsoft.CodeAnalysis.CSharp;

using SLDisMacros.Interfaces;

public class Script
{
	public static void Run(IEngine engine)
	{
		// Load XML Document
		string script = engine.Input.FileContent;
		XDocument xDoc = XDocument.Parse(script);
		XNamespace ns = "http://www.skyline.be/automation";

		// Get the ScriptParameters
		var parameters = xDoc.Descendants(ns + "ScriptParameter")
			.Select(param => new ScriptParameter
			{
				Id = param.Attribute("id")?.Value,
				Type = param.Attribute("type")?.Value,
				Values = param.Attribute("values")?.Value,
				Description = param.Element(ns + "Description")?.Value,
			});

		engine.LogToOutputWindow(String.Join(Environment.NewLine, parameters.Select(x => $"{x.Id},\t{x.Type},\t{x.Values},\t{x.Description}")));

		// Create ScriptContext class
		var builder = new TabbedStringBuilder();
		builder.AppendLine("namespace Skyline.DataMiner.Automation");
		builder.OpenCurlyBraces();

		// Using namespaces
		builder.AppendLine("using System;");
		builder.AppendLine("using System.Linq;");
		builder.AppendLine();
		builder.AppendLine("using Newtonsoft.Json;");
		builder.AppendLine();
		builder.AppendLine("using Skyline.DataMiner.Automation;");
		builder.AppendLine("using Skyline.DataMiner.Utils.InteractiveAutomationScript;");
		builder.AppendLine();

		// ScriptContext
		builder.AppendLine("public class ScriptContext");
		builder.OpenCurlyBraces();

		// Constructor
		builder.AppendLine("public ScriptContext(IEngine engine)");
		builder.OpenCurlyBraces();
		builder.AppendLine("Engine = engine;");
		builder.AppendLine();
		foreach (var parameter in parameters)
		{
			builder.AppendLine($"{parameter.Description.Sanitize()} = GetScriptParam(\"Agent Id\").Single();");
		}

		builder.CloseCurlyBraces();

		// Properties
		builder.AppendLine();
		builder.AppendLine("public IEngine Engine { get; }");

		foreach (var parameter in parameters)
		{
			builder.AppendLine();
			builder.AppendLine($"public string {parameter.Description.Sanitize()} {{ get; }}");
		}

		// Methods
		// GetScriptParam
		builder.AppendLine();
		builder.AppendLine("private static string[] GetScriptParam(string name)");
		builder.OpenCurlyBraces();

		builder.AppendLine("var rawValue = Engine.GetScriptParam(name).Value;");
		builder.AppendLine("if (String.IsNullOrEmpty(rawValue))");
		builder.OpenCurlyBraces();
		builder.AppendLine("throw new ArgumentException($\"Script Param '{name}' cannot be left empty.\");");
		builder.CloseCurlyBraces();
		builder.AppendLine();
		builder.AppendLine("if (IsJsonArray(rawValue))");
		builder.OpenCurlyBraces();
		builder.AppendLine("return JsonConvert.DeserializeObject<string[]>(rawValue);");
		builder.CloseCurlyBraces();
		builder.AppendLine("else");
		builder.OpenCurlyBraces();
		builder.AppendLine("return new[] { rawValue };");
		builder.CloseCurlyBraces();
		builder.CloseCurlyBraces();

		// IsJsonArray
		builder.AppendLine();
		builder.AppendLine("private static bool IsJsonArray(string json)");
		builder.OpenCurlyBraces();
		builder.AppendLine("try");
		builder.OpenCurlyBraces();
		builder.AppendLine("JArray.Parse(json);");
		builder.AppendLine("return true;");
		builder.CloseCurlyBraces();
		builder.AppendLine("catch");
		builder.OpenCurlyBraces();
		builder.AppendLine("return false;");
		builder.CloseCurlyBraces();
		builder.CloseCurlyBraces();

		builder.CloseCurlyBraces();
		builder.CloseCurlyBraces();

		// Copy to Clipboard
		Clipboard.SetText(builder.ToString());
	}
}

namespace Create_Script_Context_1
{
	using System.Collections.Generic;

	using Microsoft.CodeAnalysis;
	using Microsoft.CodeAnalysis.CSharp;
	using Microsoft.CodeAnalysis.CSharp.Syntax;

	using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

	public static class Generator
	{
		private static readonly string EnginePropertyName = "Engine";
		private static readonly string IsJsonArrayMethodName = "IsJsonArray";
		private static readonly string GetScriptParamName = "GetScriptParam";

		public static string Generate(string className, IEnumerable<ScriptParameter> parameters)
		{
			var properties = GenerateProperties(parameters);
			var constructor = GenerateConstructors(className, properties);
			var scriptContextClass = ClassDeclaration(className)
				.AddModifiers(Token(SyntaxKind.PublicKeyword))
				.AddMembers(constructor)
				.AddMembers(properties.Values.ToArray())
				.AddMembers(GenerateMethods());

			var namespaceComment = Token(SyntaxKind.NamespaceKeyword)
				.WithLeadingTrivia(
					Comment("//------------------------------------------------------------------------------"),
					Comment("// <auto-generated>"),
					Comment("//     This code was generated by the Create Script Context DIS Macro."),
					Comment("// </auto-generated>"),
					Comment("//------------------------------------------------------------------------------"));

			return NamespaceDeclaration(ParseName("Skyline.DataMiner.Automation"))
				.WithNamespaceKeyword(namespaceComment)
				.AddUsings(UsingDirective(IdentifierName("System")))
				.AddUsings(UsingDirective(IdentifierName("System.Linq")))
				.AddUsings(UsingDirective(IdentifierName("Newtonsoft.Json")))
				.AddUsings(UsingDirective(IdentifierName("Skyline.DataMiner.Automation")))
				.AddMembers(scriptContextClass)
				.NormalizeWhitespace()
				.GetText()
				.ToString();
		}

		private static ConstructorDeclarationSyntax[] GenerateConstructors(string className, Dictionary<ScriptParameter, PropertyDeclarationSyntax> properties)
		{
			var engineArgument = Parameter(Identifier("engine")).WithType(ParseTypeName("IEngine"));

			var propertyAssignments = new List<ExpressionStatementSyntax>
			{
				ExpressionStatement(
					AssignmentExpression(
						SyntaxKind.SimpleAssignmentExpression,
						IdentifierName(EnginePropertyName),
						IdentifierName(engineArgument.Identifier.Text))),
			};

			foreach(var property in properties)
			{
				var assignment = ExpressionStatement(
					AssignmentExpression(
						SyntaxKind.SimpleAssignmentExpression,
						IdentifierName(property.Value.Identifier.Text),
						MemberAccessExpression(
							SyntaxKind.SimpleMemberAccessExpression,
							IdentifierName(GetScriptParamName),
							IdentifierName(property.Key.Description))
						.GetMethod("Single")));
				propertyAssignments.Add(assignment);
			}

			var constructor = ConstructorDeclaration(className)
				.AddModifiers(Token(SyntaxKind.PublicKeyword))
				.AddParameterListParameters(engineArgument)
				.AddBodyStatements(propertyAssignments.ToArray());

			return new[] { constructor };
		}

		private static Dictionary<ScriptParameter, PropertyDeclarationSyntax> GenerateProperties(IEnumerable<ScriptParameter> parameters)
		{
			var properties = new Dictionary<ScriptParameter, PropertyDeclarationSyntax>();
			foreach (var parameter in parameters)
			{
				var prop = PropertyDeclaration(PredefinedType(Token(SyntaxKind.StringKeyword)), parameter.Description)
					.AddModifiers(Token(SyntaxKind.PublicKeyword))
					.AddAccessorListAccessors(
						AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
						.WithSemicolonToken(Token(SyntaxKind.SemicolonToken)));

				properties.Add(parameter, prop);
			}

			return properties;
		}

		private static MethodDeclarationSyntax[] GenerateMethods()
		{
			// IsJsonArray method
			var isJsonArrayArgument = Parameter(Identifier("name")).WithType(PredefinedType(Token(SyntaxKind.StringKeyword)));
			var parseInvocation = ExpressionStatement(
				InvocationExpression(
					MemberAccessExpression(
						SyntaxKind.SimpleMemberAccessExpression,
						IdentifierName("JArray"),
						IdentifierName("Parse")))
					.AddArgumentListArguments(Argument(IdentifierName(isJsonArrayArgument.Identifier.Text))));
			var returnTrue = ReturnStatement(LiteralExpression(SyntaxKind.TrueLiteralExpression));
			var returnFalse = ReturnStatement(LiteralExpression(SyntaxKind.FalseLiteralExpression));
			var tryCatchBlock = TryStatement()
				.WithBlock(
					Block(
						parseInvocation,
						returnTrue))
				.AddCatches(
					CatchClause()
						.AddBlockStatements(returnFalse));
			var IsJsonArrayMethod = MethodDeclaration(
				PredefinedType(Token(SyntaxKind.BoolKeyword)), IsJsonArrayMethodName)
				.AddModifiers(
					Token(SyntaxKind.PrivateKeyword),
					Token(SyntaxKind.StaticKeyword))
				.AddParameterListParameters(
					isJsonArrayArgument)
				.AddBodyStatements(tryCatchBlock);

			// GetScriptParam method
			var getScriptParamArgument = Parameter(Identifier("name")).WithType(PredefinedType(Token(SyntaxKind.StringKeyword)));
			var getScriptParam = IdentifierName(EnginePropertyName)
				.GetMethod("GetScriptParam")
					.AddArgumentListArguments(Argument(IdentifierName(getScriptParamArgument.Identifier.Text)))
				.GetProperty("Value");
			var rawValueName = "rawValue";
			var rawValueVariable = VariableDeclaration(IdentifierName("var"))
				.AddVariables(
					VariableDeclarator(rawValueName)
						.WithInitializer(EqualsValueClause(getScriptParam)));

			// Check for empty value
			var checkEmptyValue = IdentifierName(nameof(String))
				.GetMethod(nameof(String.IsNullOrEmpty))
					.AddArgumentListArguments(
						Argument(IdentifierName(rawValueName)));
			var rawValueExceptionMessage = InterpolatedStringExpression(Token(SyntaxKind.InterpolatedStringStartToken))
				.AddContents(
					InterpolatedStringText(
						Token(
							TriviaList(),
							SyntaxKind.InterpolatedStringTextToken,
							"Script Param '",
							"Script Param '",
							TriviaList())),
					Interpolation(IdentifierName(getScriptParamArgument.Identifier.Text)),
					InterpolatedStringText(
						Token(
							TriviaList(),
							SyntaxKind.InterpolatedStringTextToken,
							"' cannot be left empty.",
							"' cannot be left empty",
							TriviaList())));
			var throwEmptyValueException = ThrowStatement(
				ObjectCreationExpression(
					IdentifierName(nameof(ArgumentException)))
				.AddArgumentListArguments(Argument(rawValueExceptionMessage)));

			// Check for Json Array coming from a low code app
			var checkJsonArray = InvocationExpression(IdentifierName(IsJsonArrayMethodName))
				.AddArgumentListArguments(Argument(IdentifierName(rawValueName)));
			var returnJsonArray = ReturnStatement(
				InvocationExpression(
					MemberAccessExpression(
						SyntaxKind.SimpleMemberAccessExpression,
						IdentifierName("JsonConvert"),
						GenericName("DeserializeObject")
							.WithTypeArgumentList(
								TypeArgumentList(
									SingletonSeparatedList<TypeSyntax>(
										ArrayType(PredefinedType(Token(SyntaxKind.StringKeyword))))))))
				.AddArgumentListArguments(
					Argument(IdentifierName(rawValueName))));
			var returnSingleValue = ReturnStatement(
					ArrayCreationExpression(
						ArrayType(PredefinedType(Token(SyntaxKind.StringKeyword)))
						.WithRankSpecifiers(
							SingletonList(
								ArrayRankSpecifier(
									SingletonSeparatedList<ExpressionSyntax>(
										OmittedArraySizeExpression())))))
					.WithInitializer(
						InitializerExpression(
							SyntaxKind.ArrayInitializerExpression,
							SingletonSeparatedList<ExpressionSyntax>(
								IdentifierName(rawValueName)))));
			var GetScriptParamMethod = MethodDeclaration(ArrayType(PredefinedType(Token(SyntaxKind.StringKeyword))), GetScriptParamName)
				.AddModifiers(Token(SyntaxKind.PrivateKeyword), Token(SyntaxKind.StaticKeyword))
				.AddParameterListParameters(getScriptParamArgument)
				.AddBodyStatements(
					LocalDeclarationStatement(rawValueVariable),
					IfStatement(checkEmptyValue, throwEmptyValueException),
					IfStatement(checkJsonArray, returnJsonArray, ElseClause(returnSingleValue)));

			return new MethodDeclarationSyntax[]
			{
				IsJsonArrayMethod,
				GetScriptParamMethod,
			};
		}
	}
}

namespace Create_Script_Context_1
{
	using Microsoft.CodeAnalysis;
	using Microsoft.CodeAnalysis.CSharp;
	using Microsoft.CodeAnalysis.CSharp.Syntax;

	using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

	public static class StringExtensions
	{
		public static string Filtered(this string str)
		{
			return Regex.Replace(str, @"\W+", "");   // trim non-word characters
		}

		public static string FirstLetterToLower(this string input)
		{
			switch (input)
			{
				case null:

					throw new ArgumentNullException(nameof(input));

				case "":

					throw new ArgumentException($"{nameof(input)} cannot be empty", nameof(input));

				default:

					return input.First().ToString().ToLower() + input.Substring(1);
			}
		}

		public static string FirstLetterToUpper(this string input)
		{
			switch (input)
			{
				case null:

					throw new ArgumentNullException(nameof(input));

				case "":

					throw new ArgumentException($"{nameof(input)} cannot be empty", nameof(input));

				default:

					return input.First().ToString().ToUpper() + input.Substring(1);
			}
		}

		public static string Sanitize(this string input)
		{
			return input
				.Replace(" ", String.Empty)
				.Replace('-', '_')
				.FirstLetterToUpper();
		}
	}

	public static class GeneratorExtensions
	{
		public static readonly AccessorDeclarationSyntax DefaultPropertyGet =
			AccessorDeclaration(SyntaxKind.GetAccessorDeclaration).WithSemicolonToken(Token(SyntaxKind.SemicolonToken));

		public static readonly AccessorDeclarationSyntax DefaultPropertySet =
			AccessorDeclaration(SyntaxKind.SetAccessorDeclaration).WithSemicolonToken(Token(SyntaxKind.SemicolonToken));

		public static readonly AccessorDeclarationSyntax[] DefaultPropertyGetSet = new[]
		{
			DefaultPropertyGet,
			DefaultPropertySet,
		};

		public static IdentifierNameSyntax ToIdentifierName(this ParameterSyntax parameter)
		{
			return IdentifierName(parameter.Identifier.Text);
		}

		public static MemberAccessExpressionSyntax GetProperty(this ExpressionSyntax identifier, string property)
		{
			return MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, identifier, IdentifierName(property));
		}

		public static MemberAccessExpressionSyntax GetProperty(this ExpressionSyntax identifier, IdentifierNameSyntax property)
		{
			return MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, identifier, property);
		}

		public static MemberAccessExpressionSyntax GetProperty(this ParameterSyntax parameter, string property)
		{
			return MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName(parameter.Identifier.Text), IdentifierName(property));
		}

		public static MemberAccessExpressionSyntax GetProperty(this ParameterSyntax parameter, IdentifierNameSyntax property)
		{
			return MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName(parameter.Identifier.Text), property);
		}


		public static InvocationExpressionSyntax GetMethod(this ExpressionSyntax identifier, string method)
		{
			return InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, identifier, IdentifierName(method)));
		}

		public static InvocationExpressionSyntax GetMethod(this ExpressionSyntax identifier, IdentifierNameSyntax method)
		{
			return InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, identifier, method));
		}

		public static InvocationExpressionSyntax GetMethod(this ParameterSyntax parameter, string method)
		{
			return InvocationExpression(MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, IdentifierName(parameter.Identifier.Text), IdentifierName(method)));
		}
	}

	public class ScriptParameter
	{
		public string Id { get; set; }

		public string Type { get; set; }

		public string Values { get; set; }

		public string Description { get; set; }
	}

	public class TabbedStringBuilder
	{
		private int tabIndex = 0;
		private readonly StringBuilder sb = new StringBuilder();

		public int Length { get => sb.Length; }

		public TabbedStringBuilder RawAppend(string line)
		{
			sb.Append(line);
			return this;
		}

		public TabbedStringBuilder Append(string line)
		{
			sb.Append(new String('\t', tabIndex));
			sb.Append(line);
			return this;
		}

		public TabbedStringBuilder RawAppendLine(string line)
		{
			sb.Append(line);
			sb.Append(Environment.NewLine);
			return this;
		}

		public TabbedStringBuilder AppendLine()
		{
			sb.Append(Environment.NewLine);
			return this;
		}

		public TabbedStringBuilder AppendLine(string line)
		{
			sb.Append(new String('\t', tabIndex));
			sb.Append(line);
			sb.Append(Environment.NewLine);
			return this;
		}

		public TabbedStringBuilder OpenCurlyBraces()
		{
			sb.Append(new String('\t', tabIndex));
			sb.Append("{");
			sb.Append(Environment.NewLine);
			tabIndex++;
			return this;
		}

		public TabbedStringBuilder CloseCurlyBraces(bool newLine = true)
		{
			tabIndex--;
			sb.Append(new String('\t', tabIndex));
			sb.Append("}");
			if (newLine)
				sb.Append(Environment.NewLine);
			return this;
		}

		public TabbedStringBuilder Remove(int startIndex, int length)
		{
			sb.Remove(startIndex, length);
			return this;
		}

		public override string ToString()
		{
			return sb.ToString();
		}
	}
}]]>
		</Code>
	</Script>
</DisMacro>